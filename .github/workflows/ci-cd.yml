name: Production CI/CD Pipeline

on:
  push:
    branches: [ main, deploy-to-render ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_pass
          POSTGRES_DB: test_ecom
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-asyncio httpx
        
    - name: Set up test environment variables
      run: |
        echo "DATABASE_URL=postgresql://test_user:test_pass@localhost:5432/test_ecom" >> $GITHUB_ENV
        echo "SECRET_KEY=test-secret-key-for-github-actions-only-32-chars-long" >> $GITHUB_ENV
        echo "ALGORITHM=HS256" >> $GITHUB_ENV
        echo "ACCESS_TOKEN_EXPIRE_MINUTES=30" >> $GITHUB_ENV
        echo "STRIPE_PUBLISHABLE_KEY=pk_test_fake_key_for_testing_only" >> $GITHUB_ENV
        echo "STRIPE_SECRET_KEY=sk_test_fake_key_for_testing_only" >> $GITHUB_ENV
        echo "STRIPE_WEBHOOK_SECRET=whsec_fake_secret_for_testing_only" >> $GITHUB_ENV
        echo "ADMIN_EMAIL=admin@test.com" >> $GITHUB_ENV
        echo "ADMIN_PASSWORD=test_admin_password_secure_123" >> $GITHUB_ENV
        echo "ENVIRONMENT=testing" >> $GITHUB_ENV
        echo "DEBUG=false" >> $GITHUB_ENV
        echo "BACKEND_CORS_ORIGINS=[\"http://localhost:3000\"]" >> $GITHUB_ENV
        
    - name: Wait for PostgreSQL
      run: |
        until pg_isready -h localhost -p 5432 -U test_user; do
          echo "Waiting for PostgreSQL..."
          sleep 2
        done
        echo "PostgreSQL is ready!"
        
    - name: Create database tables
      run: |
        python -c "
        import os
        os.environ['DATABASE_URL'] = 'postgresql://test_user:test_pass@localhost:5432/test_ecom'
        os.environ['SECRET_KEY'] = 'test-secret-key-for-github-actions-only-32-chars-long'
        os.environ['STRIPE_PUBLISHABLE_KEY'] = 'pk_test_fake'
        os.environ['STRIPE_SECRET_KEY'] = 'sk_test_fake'
        os.environ['STRIPE_WEBHOOK_SECRET'] = 'whsec_fake'
        os.environ['ADMIN_EMAIL'] = 'admin@test.com'
        os.environ['ADMIN_PASSWORD'] = 'test_admin_password'
        os.environ['ENVIRONMENT'] = 'testing'
        
        from app.db.base import Base, engine
        print('Creating database tables...')
        Base.metadata.create_all(bind=engine)
        print('‚úÖ Database tables created successfully')
        
        from app.db.init_db import init_db
        from app.db.base import SessionLocal
        db = SessionLocal()
        try:
            init_db(db)
            print('‚úÖ Database initialized with admin user')
        except Exception as e:
            print(f'‚ö†Ô∏è  Database init warning: {e}')
        finally:
            db.close()
        "
        
    - name: Run import tests
      run: |
        python -c "
        print('Testing critical imports...')
        
        # Test configuration
        from app.core.config import settings
        print(f'‚úÖ Config loaded: {settings.PROJECT_NAME}')
        
        # Test models
        from app.models.user import User, UserRole
        from app.models.product import Product, Category
        from app.models.cart import Cart, CartItem
        print('‚úÖ Models imported successfully')
        
        # Test schemas
        from app.schemas.user import UserCreate, UserLogin
        from app.schemas.product import ProductCreate, CategoryCreate
        print('‚úÖ Schemas imported successfully')
        
        # Test CRUD operations
        from app.crud.user import create_user, get_user_by_email
        from app.crud.product import create_product, get_categories
        print('‚úÖ CRUD operations imported successfully')
        
        # Test API endpoints
        from app.api.v1.endpoints import auth, products, categories, cart
        print('‚úÖ API endpoints imported successfully')
        
        # Test main app
        from app.main import app
        print('‚úÖ FastAPI app created successfully')
        
        print('üéâ All critical imports passed!')
        "

    - name: Run unit tests
      run: |
        # Create a simple test file if none exists
        if [ ! -d "tests" ]; then
          mkdir tests
          cat > tests/test_basic.py << 'EOF'
import pytest
from fastapi.testclient import TestClient
from app.main import app
from app.core.config import settings

client = TestClient(app)

def test_read_root():
    response = client.get("/")
    assert response.status_code == 200
    data = response.json()
    assert "message" in data
    assert data["message"] == "E-commerce API"

def test_docs_accessible():
    response = client.get("/docs")
    assert response.status_code == 200

def test_openapi_schema():
    response = client.get("/api/v1/openapi.json")
    assert response.status_code == 200
    
def test_config_loading():
    assert settings.PROJECT_NAME == "E-commerce API"
    assert settings.VERSION == "1.0.0"
EOF
        fi
        
        # Run tests
        pytest tests/ -v --tb=short
        echo "‚úÖ Unit tests completed"

    - name: Start API server for integration tests
      run: |
        echo "Starting API server for integration tests..."
        uvicorn app.main:app --host 0.0.0.0 --port 8000 &
        API_PID=$!
        echo $API_PID > api.pid
        
        # Wait for server to start
        for i in {1..30}; do
          if curl -f http://localhost:8000/ >/dev/null 2>&1; then
            echo "‚úÖ API server is ready"
            break
          fi
          echo "Waiting for API server... ($i/30)"
          sleep 2
        done
        
    - name: Run integration tests
      run: |
        echo "Running integration tests..."
        
        # Test health endpoint
        curl -f http://localhost:8000/ || exit 1
        echo "‚úÖ Health check passed"
        
        # Test admin user creation and login
        ADMIN_LOGIN=$(curl -X POST http://localhost:8000/api/v1/auth/login \
          -H "Content-Type: application/json" \
          -d '{"email":"admin@test.com","password":"test_admin_password_secure_123"}' \
          -w "%{http_code}" -o login_response.json)
        
        if [ "$ADMIN_LOGIN" = "200" ]; then
          echo "‚úÖ Admin login successful"
          ADMIN_TOKEN=$(cat login_response.json | python -c "import sys, json; print(json.load(sys.stdin)['access_token'])")
          echo "‚úÖ Admin token obtained"
          
          # Test category creation
          curl -X POST http://localhost:8000/api/v1/categories/ \
            -H "Authorization: Bearer $ADMIN_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"name":"Test Category","description":"Test","slug":"test-category"}' \
            -f || exit 1
          echo "‚úÖ Category creation test passed"
          
          # Test product creation  
          curl -X POST http://localhost:8000/api/v1/products/ \
            -H "Authorization: Bearer $ADMIN_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"name":"Test Product","price":"10.00","sku":"TEST-001","slug":"test-product"}' \
            -f || exit 1
          echo "‚úÖ Product creation test passed"
        else
          echo "‚ùå Admin login failed"
          exit 1
        fi
        
        echo "üéâ All integration tests passed!"
        
    - name: Stop API server
      if: always()
      run: |
        if [ -f api.pid ]; then
          kill $(cat api.pid) || true
          rm api.pid
        fi

  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install security tools
      run: |
        pip install bandit[toml] safety pip-audit
        
    - name: Run dependency vulnerability scan
      run: |
        echo "Scanning for known vulnerabilities in dependencies..."
        pip-audit --requirement requirements.txt --format=json --output=dependency-vulnerabilities.json || true
        
    - name: Run Bandit security scan
      run: |
        echo "Running Bandit security scan..."
        bandit -r app/ -f json -o bandit-security-report.json -ll || true
        
        # Show summary
        if [ -f bandit-security-report.json ]; then
          echo "‚úÖ Bandit scan completed"
          python -c "
import json
try:
    with open('bandit-security-report.json', 'r') as f:
        report = json.load(f)
    print(f'Security scan results:')
    print(f'  High severity issues: {len([r for r in report.get(\"results\", []) if r.get(\"issue_severity\") == \"HIGH\"])}')
    print(f'  Medium severity issues: {len([r for r in report.get(\"results\", []) if r.get(\"issue_severity\") == \"MEDIUM\"])}')
    print(f'  Low severity issues: {len([r for r in report.get(\"results\", []) if r.get(\"issue_severity\") == \"LOW\"])}')
except Exception as e:
    print(f'Could not parse security report: {e}')
          "
        else
          echo "‚ö†Ô∏è  No security report generated"
        fi
        
    - name: Run Safety check
      run: |
        echo "Running Safety check for known security vulnerabilities..."
        safety check --json --output safety-report.json || true
        
    - name: Upload security scan results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-scan-results
        path: |
          bandit-security-report.json
          dependency-vulnerabilities.json
          safety-report.json
        if-no-files-found: warn

  deploy:
    needs: [test, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/deploy-to-render' && github.event_name == 'push'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy to Render
      env:
        RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
      run: |
        echo "üöÄ Deployment triggered to Render"
        echo "Branch: ${{ github.ref }}"
        echo "Commit: ${{ github.sha }}"
        echo "Timestamp: $(date)"
        
        if [ -n "$RENDER_API_KEY" ] && [ -n "$RENDER_SERVICE_ID" ]; then
          echo "‚úÖ Render API credentials available"
          # Here you could add actual Render API calls if needed
          # For now, Render auto-deploys from the branch
        else
          echo "‚ÑπÔ∏è  Using Render auto-deployment from branch"
        fi
        
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ Deployment pipeline completed successfully"
          echo "üåê Your API should be live at: https://ecom-api-s8lz.onrender.com"
          echo "üìö Documentation available at: https://ecom-api-s8lz.onrender.com/docs"
        else
          echo "‚ùå Deployment pipeline failed"
        fi
